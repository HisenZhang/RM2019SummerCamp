; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\motor.o --asm_dir=.\OBJ\ --list_dir=.\OBJ\ --depend=.\obj\motor.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I.\CORE -I.\USER -I.\HALLIB\STM32F4xx_HAL_Driver\Inc -I.\SYSTEM -I.\Hardware -I.\App -I.\DSP_LIB\Include -I.\FATFS -I.\FreeRTOS -I.\DMP -I.\DMP\eMPL -I.\RTE\_Project -ID:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=526 -DSTM32F427xx -DSTM32F4 -DUSE_HAL_DRIVER -DSTM32F427xx -DARM_MATH_CM4 -D__CC_ARM -DARM_MATH_MATRIX_CHECK -DARM_MATH_ROUNDING --omf_browse=.\obj\motor.crf App\Motor.c]
                          THUMB

                          AREA ||i.HAL_CAN_RxCpltCallback||, CODE, READONLY, ALIGN=2

                  HAL_CAN_RxCpltCallback PROC
;;;65     float ZGyroModuleAngle;
;;;66     void HAL_CAN_RxCpltCallback(CAN_HandleTypeDef* _hcan)
000000  b530              PUSH     {r4,r5,lr}
;;;67     {
000002  4604              MOV      r4,r0
;;;68     	u8 i;
;;;69     	switch(_hcan->pRxMsg->StdId)
000004  6b60              LDR      r0,[r4,#0x34]
000006  6800              LDR      r0,[r0,#0]
000008  f2402205          MOV      r2,#0x205
00000c  1a81              SUBS     r1,r0,r2
00000e  4290              CMP      r0,r2
000010  d018              BEQ      |L1.68|
000012  dc09              BGT      |L1.40|
000014  f2a02001          SUB      r0,r0,#0x201
000018  b180              CBZ      r0,|L1.60|
00001a  2801              CMP      r0,#1
00001c  d00f              BEQ      |L1.62|
00001e  2802              CMP      r0,#2
000020  d00e              BEQ      |L1.64|
000022  2803              CMP      r0,#3
000024  d17d              BNE      |L1.290|
000026  e00c              B        |L1.66|
                  |L1.40|
000028  2901              CMP      r1,#1
00002a  d00c              BEQ      |L1.70|
00002c  2902              CMP      r1,#2
00002e  d00b              BEQ      |L1.72|
000030  2903              CMP      r1,#3
000032  d00a              BEQ      |L1.74|
000034  f5b17ffe          CMP      r1,#0x1fc
000038  d173              BNE      |L1.290|
00003a  e03f              B        |L1.188|
                  |L1.60|
;;;70     	{
;;;71     		case CAN_3510Moto1_ID:
;;;72     		case CAN_3510Moto2_ID:
00003c  bf00              NOP      
                  |L1.62|
;;;73     		case CAN_3510Moto3_ID:
00003e  bf00              NOP      
                  |L1.64|
;;;74     		case CAN_3510Moto4_ID:
000040  bf00              NOP      
                  |L1.66|
;;;75     		case CAN_3510Moto5_ID:
000042  bf00              NOP      
                  |L1.68|
;;;76     		case CAN_3510Moto6_ID:
000044  bf00              NOP      
                  |L1.70|
;;;77     		case CAN_3510Moto7_ID:
000046  bf00              NOP      
                  |L1.72|
;;;78     		case CAN_3510Moto8_ID:
000048  bf00              NOP      
                  |L1.74|
;;;79     		{
;;;80     				i = _hcan->pRxMsg->StdId - CAN_3510Moto1_ID;
00004a  6b60              LDR      r0,[r4,#0x34]
00004c  7800              LDRB     r0,[r0,#0]
00004e  1e40              SUBS     r0,r0,#1
000050  b2c5              UXTB     r5,r0
;;;81     				moto_chassis[i].msg_cnt++ <= 50	?	get_moto_offset(&moto_chassis[i], _hcan) : get_moto_measure(&moto_chassis[i], _hcan);
000052  eb050045          ADD      r0,r5,r5,LSL #1
000056  eb0000c5          ADD      r0,r0,r5,LSL #3
00005a  493b              LDR      r1,|L1.328|
00005c  eb010080          ADD      r0,r1,r0,LSL #2
000060  6a81              LDR      r1,[r0,#0x28]
000062  eb050045          ADD      r0,r5,r5,LSL #1
000066  eb0000c5          ADD      r0,r0,r5,LSL #3
00006a  4a37              LDR      r2,|L1.328|
00006c  eb020080          ADD      r0,r2,r0,LSL #2
000070  6a80              LDR      r0,[r0,#0x28]
000072  1c40              ADDS     r0,r0,#1
000074  eb050245          ADD      r2,r5,r5,LSL #1
000078  eb0202c5          ADD      r2,r2,r5,LSL #3
00007c  4b32              LDR      r3,|L1.328|
00007e  eb030282          ADD      r2,r3,r2,LSL #2
000082  6290              STR      r0,[r2,#0x28]
000084  2932              CMP      r1,#0x32
000086  d80a              BHI      |L1.158|
000088  eb050145          ADD      r1,r5,r5,LSL #1
00008c  eb0101c5          ADD      r1,r1,r5,LSL #3
000090  461a              MOV      r2,r3
000092  eb020081          ADD      r0,r2,r1,LSL #2
000096  4621              MOV      r1,r4
000098  f7fffffe          BL       get_moto_offset
00009c  e009              B        |L1.178|
                  |L1.158|
00009e  eb050145          ADD      r1,r5,r5,LSL #1
0000a2  eb0101c5          ADD      r1,r1,r5,LSL #3
0000a6  4a28              LDR      r2,|L1.328|
0000a8  eb020081          ADD      r0,r2,r1,LSL #2
0000ac  4621              MOV      r1,r4
0000ae  f7fffffe          BL       get_moto_measure
                  |L1.178|
;;;82     				get_moto_measure(&moto_info,_hcan);
0000b2  4621              MOV      r1,r4
0000b4  4825              LDR      r0,|L1.332|
0000b6  f7fffffe          BL       get_moto_measure
;;;83     				break;
0000ba  e032              B        |L1.290|
                  |L1.188|
;;;84     		}
;;;85     		case SINGLE_GYRO_ID:
;;;86     		{
;;;87     			single_gyro.angle = 0.001f * ((int32_t)( (_hcan->pRxMsg->Data[0] << 24) | (_hcan->pRxMsg->Data[1] << 16) | (_hcan->pRxMsg->Data[2] << 8) | (_hcan->pRxMsg->Data[3]) ) );
0000bc  6b60              LDR      r0,[r4,#0x34]
0000be  7d00              LDRB     r0,[r0,#0x14]
0000c0  0601              LSLS     r1,r0,#24
0000c2  6b60              LDR      r0,[r4,#0x34]
0000c4  7d40              LDRB     r0,[r0,#0x15]
0000c6  ea414100          ORR      r1,r1,r0,LSL #16
0000ca  6b60              LDR      r0,[r4,#0x34]
0000cc  7d80              LDRB     r0,[r0,#0x16]
0000ce  ea412000          ORR      r0,r1,r0,LSL #8
0000d2  6b61              LDR      r1,[r4,#0x34]
0000d4  7dc9              LDRB     r1,[r1,#0x17]
0000d6  4308              ORRS     r0,r0,r1
0000d8  ee000a10          VMOV     s0,r0
0000dc  eeb80ac0          VCVT.F32.S32 s0,s0
0000e0  eddf0a1b          VLDR     s1,|L1.336|
0000e4  ee200a20          VMUL.F32 s0,s0,s1
0000e8  481a              LDR      r0,|L1.340|
0000ea  ed800a00          VSTR     s0,[r0,#0]
;;;88           single_gyro.gyro = 0.001f * ((int32_t)( (_hcan->pRxMsg->Data[4] << 24) | (_hcan->pRxMsg->Data[5] << 16) | (_hcan->pRxMsg->Data[6] << 8) | (_hcan->pRxMsg->Data[7]) ) );
0000ee  6b60              LDR      r0,[r4,#0x34]
0000f0  7e00              LDRB     r0,[r0,#0x18]
0000f2  0601              LSLS     r1,r0,#24
0000f4  6b60              LDR      r0,[r4,#0x34]
0000f6  7e40              LDRB     r0,[r0,#0x19]
0000f8  ea414100          ORR      r1,r1,r0,LSL #16
0000fc  6b60              LDR      r0,[r4,#0x34]
0000fe  7e80              LDRB     r0,[r0,#0x1a]
000100  ea412000          ORR      r0,r1,r0,LSL #8
000104  6b61              LDR      r1,[r4,#0x34]
000106  7ec9              LDRB     r1,[r1,#0x1b]
000108  4308              ORRS     r0,r0,r1
00010a  ee000a10          VMOV     s0,r0
00010e  eeb80ac0          VCVT.F32.S32 s0,s0
000112  eddf0a0f          VLDR     s1,|L1.336|
000116  ee200a20          VMUL.F32 s0,s0,s1
00011a  480e              LDR      r0,|L1.340|
00011c  ed800a01          VSTR     s0,[r0,#4]
;;;89           break;
000120  bf00              NOP      
                  |L1.290|
000122  bf00              NOP                            ;83
;;;90     		}
;;;91     	}
;;;92     	__HAL_CAN_ENABLE_IT(&hcan1, CAN_IT_FMP0);
000124  480c              LDR      r0,|L1.344|
000126  6800              LDR      r0,[r0,#0]  ; hcan1
000128  6940              LDR      r0,[r0,#0x14]
00012a  f0400002          ORR      r0,r0,#2
00012e  490a              LDR      r1,|L1.344|
000130  6809              LDR      r1,[r1,#0]  ; hcan1
000132  6148              STR      r0,[r1,#0x14]
;;;93     	__HAL_CAN_ENABLE_IT(&hcan2, CAN_IT_FMP0);
000134  4809              LDR      r0,|L1.348|
000136  6800              LDR      r0,[r0,#0]  ; hcan2
000138  6940              LDR      r0,[r0,#0x14]
00013a  f0400002          ORR      r0,r0,#2
00013e  4907              LDR      r1,|L1.348|
000140  6809              LDR      r1,[r1,#0]  ; hcan2
000142  6148              STR      r0,[r1,#0x14]
;;;94     }
000144  bd30              POP      {r4,r5,pc}
;;;95     void get_moto_measure(moto_measure_t *ptr, CAN_HandleTypeDef* hcan)
                          ENDP

000146  0000              DCW      0x0000
                  |L1.328|
                          DCD      moto_chassis
                  |L1.332|
                          DCD      moto_info
                  |L1.336|
000150  3a83126f          DCFS     0x3a83126f ; 0.0010000000474974513
                  |L1.340|
                          DCD      single_gyro
                  |L1.344|
                          DCD      hcan1
                  |L1.348|
                          DCD      hcan2

                          AREA ||i.Motor_Init||, CODE, READONLY, ALIGN=2

                  Motor_Init PROC
;;;8      void get_moto_offset(moto_measure_t *ptr, CAN_HandleTypeDef* hcan);
;;;9      void Motor_Init(void)
000000  b510              PUSH     {r4,lr}
;;;10     {
;;;11     	my_can_filter_init_recv_all(&hcan1);
000002  4806              LDR      r0,|L2.28|
000004  f7fffffe          BL       my_can_filter_init_recv_all
;;;12     	HAL_CAN_Receive_IT(&hcan1, CAN_FIFO0);
000008  2100              MOVS     r1,#0
00000a  4804              LDR      r0,|L2.28|
00000c  f7fffffe          BL       HAL_CAN_Receive_IT
;;;13     	HAL_CAN_Receive_IT(&hcan2, CAN_FIFO0);
000010  2100              MOVS     r1,#0
000012  4803              LDR      r0,|L2.32|
000014  f7fffffe          BL       HAL_CAN_Receive_IT
;;;14     }
000018  bd10              POP      {r4,pc}
;;;15     void my_can_filter_init_recv_all(CAN_HandleTypeDef* _hcan)
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      hcan1
                  |L2.32|
                          DCD      hcan2

                          AREA ||i.can_filter_recv_special||, CODE, READONLY, ALIGN=1

                  can_filter_recv_special PROC
;;;45     }
;;;46     void can_filter_recv_special(CAN_HandleTypeDef* hcan, uint8_t filter_number, uint16_t filtered_id)
000000  b570              PUSH     {r4-r6,lr}
;;;47     {
000002  b08a              SUB      sp,sp,#0x28
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
;;;48     	CAN_FilterConfTypeDef cf;
;;;49     	cf.FilterNumber = filter_number;
00000a  9505              STR      r5,[sp,#0x14]
;;;50     	cf.FilterMode = CAN_FILTERMODE_IDMASK;
00000c  2000              MOVS     r0,#0
00000e  9006              STR      r0,[sp,#0x18]
;;;51     	cf.FilterScale = CAN_FILTERSCALE_32BIT;
000010  2001              MOVS     r0,#1
000012  9007              STR      r0,[sp,#0x1c]
;;;52     	cf.FilterIdHigh = (filtered_id<<21)>>16;
000014  0160              LSLS     r0,r4,#5
000016  b200              SXTH     r0,r0
000018  9000              STR      r0,[sp,#0]
;;;53     	cf.FilterIdLow = filtered_id<<21;
00001a  0560              LSLS     r0,r4,#21
00001c  9001              STR      r0,[sp,#4]
;;;54     	cf.FilterMaskIdHigh = 0xFFFF;
00001e  f64f70ff          MOV      r0,#0xffff
000022  9002              STR      r0,[sp,#8]
;;;55     	cf.FilterMaskIdLow = 0xFFF8;
000024  1fc0              SUBS     r0,r0,#7
000026  9003              STR      r0,[sp,#0xc]
;;;56     	cf.FilterFIFOAssignment = CAN_FilterFIFO0;
000028  2000              MOVS     r0,#0
00002a  9004              STR      r0,[sp,#0x10]
;;;57     	cf.BankNumber = 14;
00002c  200e              MOVS     r0,#0xe
00002e  9009              STR      r0,[sp,#0x24]
;;;58     	cf.FilterActivation = ENABLE;
000030  2001              MOVS     r0,#1
000032  9008              STR      r0,[sp,#0x20]
;;;59     	HAL_CAN_ConfigFilter(hcan, &cf);
000034  4669              MOV      r1,sp
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       HAL_CAN_ConfigFilter
;;;60     } 
00003c  b00a              ADD      sp,sp,#0x28
00003e  bd70              POP      {r4-r6,pc}
;;;61     HAL_StatusTypeDef can_send_msg()
                          ENDP


                          AREA ||i.can_send_msg||, CODE, READONLY, ALIGN=1

                  can_send_msg PROC
;;;60     } 
;;;61     HAL_StatusTypeDef can_send_msg()
000000  2000              MOVS     r0,#0
;;;62     { 
;;;63     	return HAL_OK;
;;;64     }
000002  4770              BX       lr
;;;65     float ZGyroModuleAngle;
                          ENDP


                          AREA ||i.get_moto_measure||, CODE, READONLY, ALIGN=1

                  get_moto_measure PROC
;;;94     }
;;;95     void get_moto_measure(moto_measure_t *ptr, CAN_HandleTypeDef* hcan)
000000  8902              LDRH     r2,[r0,#8]
;;;96     {
;;;97     	ptr->last_angle = ptr->angle;
000002  8142              STRH     r2,[r0,#0xa]
;;;98     	ptr->angle = (uint16_t)(hcan->pRxMsg->Data[0]<<8 | hcan->pRxMsg->Data[1]) ;
000004  6b4a              LDR      r2,[r1,#0x34]
000006  7d52              LDRB     r2,[r2,#0x15]
000008  6b4b              LDR      r3,[r1,#0x34]
00000a  7d1b              LDRB     r3,[r3,#0x14]
00000c  ea422203          ORR      r2,r2,r3,LSL #8
000010  8102              STRH     r2,[r0,#8]
;;;99     	ptr->real_current  = (int16_t)(hcan->pRxMsg->Data[2]<<8 | hcan->pRxMsg->Data[3]);
000012  6b4a              LDR      r2,[r1,#0x34]
000014  7dd3              LDRB     r3,[r2,#0x17]
000016  7d92              LDRB     r2,[r2,#0x16]
000018  ea432202          ORR      r2,r3,r2,LSL #8
00001c  b212              SXTH     r2,r2
00001e  8042              STRH     r2,[r0,#2]
;;;100    	ptr->speed_rpm = ptr->real_current;
000020  8842              LDRH     r2,[r0,#2]
000022  8002              STRH     r2,[r0,#0]
;;;101    	ptr->given_current = (int16_t)(hcan->pRxMsg->Data[4]<<8 | hcan->pRxMsg->Data[5])/-5;
000024  6b4a              LDR      r2,[r1,#0x34]
000026  7e53              LDRB     r3,[r2,#0x19]
000028  7e12              LDRB     r2,[r2,#0x18]
00002a  ea432202          ORR      r2,r3,r2,LSL #8
00002e  b212              SXTH     r2,r2
000030  f06f0304          MVN      r3,#4
000034  fb92f2f3          SDIV     r2,r2,r3
000038  b212              SXTH     r2,r2
00003a  8082              STRH     r2,[r0,#4]
;;;102    	ptr->hall = hcan->pRxMsg->Data[6];
00003c  6b4a              LDR      r2,[r1,#0x34]
00003e  7e92              LDRB     r2,[r2,#0x1a]
000040  7182              STRB     r2,[r0,#6]
;;;103    	if(ptr->angle - ptr->last_angle > 4096)
000042  8902              LDRH     r2,[r0,#8]
000044  8943              LDRH     r3,[r0,#0xa]
000046  1ad2              SUBS     r2,r2,r3
000048  f5b25f80          CMP      r2,#0x1000
00004c  dd03              BLE      |L5.86|
;;;104    		ptr->round_cnt --;
00004e  6902              LDR      r2,[r0,#0x10]
000050  1e52              SUBS     r2,r2,#1
000052  6102              STR      r2,[r0,#0x10]
000054  e008              B        |L5.104|
                  |L5.86|
;;;105    	else if (ptr->angle - ptr->last_angle < -4096)
000056  8902              LDRH     r2,[r0,#8]
000058  8943              LDRH     r3,[r0,#0xa]
00005a  1ad2              SUBS     r2,r2,r3
00005c  f5125f80          CMN      r2,#0x1000
000060  da02              BGE      |L5.104|
;;;106    		ptr->round_cnt ++;
000062  6902              LDR      r2,[r0,#0x10]
000064  1c52              ADDS     r2,r2,#1
000066  6102              STR      r2,[r0,#0x10]
                  |L5.104|
;;;107    	ptr->total_angle = ptr->round_cnt * 8192 + ptr->angle - ptr->offset_angle;
000068  8903              LDRH     r3,[r0,#8]
00006a  6902              LDR      r2,[r0,#0x10]
00006c  eb033242          ADD      r2,r3,r2,LSL #13
000070  8983              LDRH     r3,[r0,#0xc]
000072  1ad2              SUBS     r2,r2,r3
000074  6142              STR      r2,[r0,#0x14]
;;;108    }
000076  4770              BX       lr
;;;109    void get_moto_offset(moto_measure_t *ptr, CAN_HandleTypeDef* hcan)
                          ENDP


                          AREA ||i.get_moto_offset||, CODE, READONLY, ALIGN=1

                  get_moto_offset PROC
;;;108    }
;;;109    void get_moto_offset(moto_measure_t *ptr, CAN_HandleTypeDef* hcan)
000000  6b4a              LDR      r2,[r1,#0x34]
;;;110    {
;;;111    	ptr->angle = (uint16_t)(hcan->pRxMsg->Data[0]<<8 | hcan->pRxMsg->Data[1]) ;
000002  7d52              LDRB     r2,[r2,#0x15]
000004  6b4b              LDR      r3,[r1,#0x34]
000006  7d1b              LDRB     r3,[r3,#0x14]
000008  ea422203          ORR      r2,r2,r3,LSL #8
00000c  8102              STRH     r2,[r0,#8]
;;;112    	ptr->offset_angle = ptr->angle;
00000e  8902              LDRH     r2,[r0,#8]
000010  8182              STRH     r2,[r0,#0xc]
;;;113    }
000012  4770              BX       lr
;;;114    
                          ENDP


                          AREA ||i.get_total_angle||, CODE, READONLY, ALIGN=1

                  get_total_angle PROC
;;;115    #define ABS(x)	( (x>0) ? (x) : (-x) )
;;;116    void get_total_angle(moto_measure_t *p)
000000  b530              PUSH     {r4,r5,lr}
;;;117    {
;;;118    	int res1, res2, delta;
;;;119    	if(p->angle < p->last_angle)
000002  8904              LDRH     r4,[r0,#8]
000004  8945              LDRH     r5,[r0,#0xa]
000006  42ac              CMP      r4,r5
000008  da08              BGE      |L7.28|
;;;120    	{
;;;121    		res1 = p->angle + 8192 - p->last_angle;
00000a  8904              LDRH     r4,[r0,#8]
00000c  f5045400          ADD      r4,r4,#0x2000
000010  8945              LDRH     r5,[r0,#0xa]
000012  1b61              SUBS     r1,r4,r5
;;;122    		res2 = p->angle - p->last_angle;
000014  8904              LDRH     r4,[r0,#8]
000016  8945              LDRH     r5,[r0,#0xa]
000018  1b62              SUBS     r2,r4,r5
00001a  e007              B        |L7.44|
                  |L7.28|
;;;123    	}
;;;124    	else
;;;125    	{
;;;126    		res1 = p->angle - 8192 - p->last_angle;
00001c  8904              LDRH     r4,[r0,#8]
00001e  f5a45400          SUB      r4,r4,#0x2000
000022  8945              LDRH     r5,[r0,#0xa]
000024  1b61              SUBS     r1,r4,r5
;;;127    		res2 = p->angle - p->last_angle;
000026  8904              LDRH     r4,[r0,#8]
000028  8945              LDRH     r5,[r0,#0xa]
00002a  1b62              SUBS     r2,r4,r5
                  |L7.44|
;;;128    	}
;;;129    	if(ABS(res1)<ABS(res2))
00002c  2900              CMP      r1,#0
00002e  dd01              BLE      |L7.52|
000030  460c              MOV      r4,r1
000032  e000              B        |L7.54|
                  |L7.52|
000034  424c              RSBS     r4,r1,#0
                  |L7.54|
000036  2a00              CMP      r2,#0
000038  dd01              BLE      |L7.62|
00003a  4615              MOV      r5,r2
00003c  e000              B        |L7.64|
                  |L7.62|
00003e  4255              RSBS     r5,r2,#0
                  |L7.64|
000040  42ac              CMP      r4,r5
000042  da01              BGE      |L7.72|
;;;130    		delta = res1;
000044  460b              MOV      r3,r1
000046  e000              B        |L7.74|
                  |L7.72|
;;;131    	else
;;;132    		delta = res2;
000048  4613              MOV      r3,r2
                  |L7.74|
;;;133    	p->total_angle += delta;
00004a  6944              LDR      r4,[r0,#0x14]
00004c  441c              ADD      r4,r4,r3
00004e  6144              STR      r4,[r0,#0x14]
;;;134    	p->last_angle = p->angle;
000050  8904              LDRH     r4,[r0,#8]
000052  8144              STRH     r4,[r0,#0xa]
;;;135    }
000054  bd30              POP      {r4,r5,pc}
;;;136    void set_moto_current(CAN_HandleTypeDef* hcan, s16 iq1, s16 iq2, s16 iq3, s16 iq4,u32 Motor_ID)
                          ENDP


                          AREA ||i.my_can_filter_init_recv_all||, CODE, READONLY, ALIGN=2

                  my_can_filter_init_recv_all PROC
;;;14     }
;;;15     void my_can_filter_init_recv_all(CAN_HandleTypeDef* _hcan)
000000  b510              PUSH     {r4,lr}
;;;16     {
000002  b08a              SUB      sp,sp,#0x28
000004  4604              MOV      r4,r0
;;;17     	CAN_FilterConfTypeDef		CAN_FilterConfigStructure;
;;;18     	static CanTxMsgTypeDef		Tx1Message;
;;;19     	static CanRxMsgTypeDef 		Rx1Message;
;;;20     	static CanTxMsgTypeDef		Tx2Message;
;;;21     	static CanRxMsgTypeDef 		Rx2Message;
;;;22     	CAN_FilterConfigStructure.FilterNumber = 0;
000006  2000              MOVS     r0,#0
000008  9005              STR      r0,[sp,#0x14]
;;;23     	CAN_FilterConfigStructure.FilterMode = CAN_FILTERMODE_IDMASK;
00000a  9006              STR      r0,[sp,#0x18]
;;;24     	CAN_FilterConfigStructure.FilterScale = CAN_FILTERSCALE_32BIT;
00000c  2001              MOVS     r0,#1
00000e  9007              STR      r0,[sp,#0x1c]
;;;25     	CAN_FilterConfigStructure.FilterIdHigh = 0x0000;
000010  2000              MOVS     r0,#0
000012  9000              STR      r0,[sp,#0]
;;;26     	CAN_FilterConfigStructure.FilterIdLow = 0x0000;
000014  9001              STR      r0,[sp,#4]
;;;27     	CAN_FilterConfigStructure.FilterMaskIdHigh = 0x0000;
000016  9002              STR      r0,[sp,#8]
;;;28     	CAN_FilterConfigStructure.FilterMaskIdLow = 0x0000;
000018  9003              STR      r0,[sp,#0xc]
;;;29     	CAN_FilterConfigStructure.FilterFIFOAssignment = CAN_FilterFIFO0;
00001a  9004              STR      r0,[sp,#0x10]
;;;30     	CAN_FilterConfigStructure.BankNumber = 14;
00001c  200e              MOVS     r0,#0xe
00001e  9009              STR      r0,[sp,#0x24]
;;;31     	CAN_FilterConfigStructure.FilterActivation = ENABLE;
000020  2001              MOVS     r0,#1
000022  9008              STR      r0,[sp,#0x20]
;;;32     	HAL_CAN_ConfigFilter(_hcan, &CAN_FilterConfigStructure);
000024  4669              MOV      r1,sp
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       HAL_CAN_ConfigFilter
;;;33     	CAN_FilterConfigStructure.FilterNumber = 14;
00002c  200e              MOVS     r0,#0xe
00002e  9005              STR      r0,[sp,#0x14]
;;;34     	HAL_CAN_ConfigFilter(_hcan, &CAN_FilterConfigStructure);
000030  4669              MOV      r1,sp
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       HAL_CAN_ConfigFilter
;;;35     	if(_hcan == &hcan1)
000038  4807              LDR      r0,|L8.88|
00003a  4284              CMP      r4,r0
00003c  d103              BNE      |L8.70|
;;;36     	{
;;;37     		_hcan->pTxMsg = &Tx1Message;
00003e  4807              LDR      r0,|L8.92|
000040  6320              STR      r0,[r4,#0x30]
;;;38     		_hcan->pRxMsg = &Rx1Message;
000042  4807              LDR      r0,|L8.96|
000044  6360              STR      r0,[r4,#0x34]
                  |L8.70|
;;;39     	}
;;;40     	if(_hcan == &hcan2)
000046  4807              LDR      r0,|L8.100|
000048  4284              CMP      r4,r0
00004a  d103              BNE      |L8.84|
;;;41     	{
;;;42     		_hcan->pTxMsg = &Tx2Message;
00004c  4806              LDR      r0,|L8.104|
00004e  6320              STR      r0,[r4,#0x30]
;;;43     		_hcan->pRxMsg = &Rx2Message;
000050  4806              LDR      r0,|L8.108|
000052  6360              STR      r0,[r4,#0x34]
                  |L8.84|
;;;44     	}
;;;45     }
000054  b00a              ADD      sp,sp,#0x28
000056  bd10              POP      {r4,pc}
;;;46     void can_filter_recv_special(CAN_HandleTypeDef* hcan, uint8_t filter_number, uint16_t filtered_id)
                          ENDP

                  |L8.88|
                          DCD      hcan1
                  |L8.92|
                          DCD      Tx1Message
                  |L8.96|
                          DCD      Rx1Message
                  |L8.100|
                          DCD      hcan2
                  |L8.104|
                          DCD      Tx2Message
                  |L8.108|
                          DCD      Rx2Message

                          AREA ||i.set_moto_current||, CODE, READONLY, ALIGN=1

                  set_moto_current PROC
;;;135    }
;;;136    void set_moto_current(CAN_HandleTypeDef* hcan, s16 iq1, s16 iq2, s16 iq3, s16 iq4,u32 Motor_ID)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;137    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9dd8908          LDRD     r8,r9,[sp,#0x20]
;;;138    	hcan->pTxMsg->StdId = Motor_ID;
000010  6b20              LDR      r0,[r4,#0x30]
000012  f8c09000          STR      r9,[r0,#0]
;;;139    	hcan->pTxMsg->IDE = CAN_ID_STD;
000016  2000              MOVS     r0,#0
000018  6b21              LDR      r1,[r4,#0x30]
00001a  6088              STR      r0,[r1,#8]
;;;140    	hcan->pTxMsg->RTR = CAN_RTR_DATA;
00001c  6b21              LDR      r1,[r4,#0x30]
00001e  60c8              STR      r0,[r1,#0xc]
;;;141    	hcan->pTxMsg->DLC = 0x08;
000020  2008              MOVS     r0,#8
000022  6b21              LDR      r1,[r4,#0x30]
000024  6108              STR      r0,[r1,#0x10]
;;;142    	hcan->pTxMsg->Data[0] = iq1 >> 8;
000026  0a28              LSRS     r0,r5,#8
000028  6b21              LDR      r1,[r4,#0x30]
00002a  7508              STRB     r0,[r1,#0x14]
;;;143    	hcan->pTxMsg->Data[1] = iq1;
00002c  6b20              LDR      r0,[r4,#0x30]
00002e  7545              STRB     r5,[r0,#0x15]
;;;144    	hcan->pTxMsg->Data[2] = iq2 >> 8;
000030  0a31              LSRS     r1,r6,#8
000032  6b20              LDR      r0,[r4,#0x30]
000034  7581              STRB     r1,[r0,#0x16]
;;;145    	hcan->pTxMsg->Data[3] = iq2;
000036  6b20              LDR      r0,[r4,#0x30]
000038  75c6              STRB     r6,[r0,#0x17]
;;;146    	hcan->pTxMsg->Data[4] = iq3 >> 8;
00003a  0a39              LSRS     r1,r7,#8
00003c  6b20              LDR      r0,[r4,#0x30]
00003e  7601              STRB     r1,[r0,#0x18]
;;;147    	hcan->pTxMsg->Data[5] = iq3;
000040  6b20              LDR      r0,[r4,#0x30]
000042  7647              STRB     r7,[r0,#0x19]
;;;148    	hcan->pTxMsg->Data[6] = iq4 >> 8;
000044  ea4f2118          LSR      r1,r8,#8
000048  6b20              LDR      r0,[r4,#0x30]
00004a  7681              STRB     r1,[r0,#0x1a]
;;;149    	hcan->pTxMsg->Data[7] = iq4;
00004c  6b20              LDR      r0,[r4,#0x30]
00004e  f880801b          STRB     r8,[r0,#0x1b]
;;;150    	HAL_CAN_Transmit(hcan, 1000);
000052  f44f717a          MOV      r1,#0x3e8
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       HAL_CAN_Transmit
;;;151    }	
00005c  e8bd87f0          POP      {r4-r10,pc}
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  moto_chassis
                          %        352
                  moto_info
                          %        44
                  Tx1Message
                          %        28
                  Rx1Message
                          %        36
                  Tx2Message
                          %        28
                  Rx2Message
                          %        36

                          AREA ||.data||, DATA, ALIGN=2

                  single_gyro
                          %        8
                  ZGyroModuleAngle
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "App\\Motor.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_Motor_c_56dfef2b____REV16|
#line 388 ".\\CORE\\cmsis_armcc.h"
|__asm___7_Motor_c_56dfef2b____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_Motor_c_56dfef2b____REVSH|
#line 402
|__asm___7_Motor_c_56dfef2b____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___7_Motor_c_56dfef2b____RRX|
#line 587
|__asm___7_Motor_c_56dfef2b____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
